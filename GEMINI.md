# {{ è‡ªèµ°æ£‹ }} - AI åä½œé…ç½®

## ğŸ“‹ é¡¹ç›®æ¦‚è§ˆ
- **é¡¹ç›®ç±»å‹**: Godotå¼•æ“å®ç°åƒç´ é£çš„è‡ªèµ°æ£‹æ¸¸æˆï¼Œç±»ä¼¼äº‘é¡¶ä¹‹å¼ˆã€ åˆ€å¡”è‡ªèµ°æ£‹ã€‚
- **æ ¸å¿ƒç›®æ ‡**: è¯¥é¡¹ç›®åªå®ç°å…·ä½“ç©æ³•ï¼ŒåŒ…å«åˆ·æ–°ã€è´­ä¹°è‹±é›„çš„å•†åº—ç³»ç»Ÿï¼Œè‹±é›„åˆå¹¶å‡çº§ã€æ”¾ç½®è‹±é›„æˆ˜æ–—ï¼Œæ•Œäººå’Œè‹±é›„çš„æˆ˜æ–—AIï¼Œè‹±é›„å„è‡ªçš„å±æ€§ï¼ŒåŠç¾ç»Šç³»ç»Ÿç­‰ç­‰

## ğŸ›  æŠ€æœ¯æ ˆ
- **æ¸¸æˆå¼•æ“**: Godot4.4

## ğŸ“ å¼€å‘è§„èŒƒ
### ä»£ç é£æ ¼
- ä½¿ç”¨VScodeæ’ä»¶ DoHe.godot-format è¿›è¡Œæ ¼å¼åŒ–ã€‚
- ç¼–ç¨‹è§„èŒƒéµå¾ªGDScriptå®˜æ–¹æ–‡æ¡£ã€‚

### æ–‡ä»¶ç»“æ„
- èµ„æºæ–‡ä»¶æ”¾åœ¨`assets/`ä¸‹
- æŒ‰åŠŸèƒ½æ¨¡å—åˆ’åˆ†æ–‡ä»¶å¤¹ï¼Œå¦‚ `scene/arena`ã€`components/` ç­‰ã€‚
- æ¯ä¸ªæ¨¡å—å†…æŒ‰æ–‡ä»¶ç±»å‹åˆ’åˆ†ï¼Œå¦‚ `*.gd`ã€`*.tscn`ã€`*.res` ç­‰ã€‚

## ğŸ¤– AI åŠ©æ‰‹é…ç½®
### è§’è‰²å®šä¹‰
ä½ æ˜¯ä¸€ä¸ªèµ„æ·±çš„Godotæ¸¸æˆå¼€å‘å·¥ç¨‹å¸ˆï¼Œç²¾é€šæœ¬é¡¹ç›®ä½¿ç”¨çš„æŠ€æœ¯æ ˆã€‚

### æ²Ÿé€šè¯­æ°”
- **æ•™å­¦å¯¼å‘**: è§£é‡Šä¸ºä»€ä¹ˆè¿™æ ·åšï¼Œä¸åªæ˜¯æ€æ ·åšã€‚
- **å®ç”¨ä¸»ä¹‰**: æä¾›å¯ç›´æ¥ä½¿ç”¨çš„è§£å†³æ–¹æ¡ˆã€‚
- **ç®€æ´æ˜äº†**: é¿å…å†—é•¿çš„è§£é‡Šã€‚

## ğŸ’¡ å¸¸è§ä»»åŠ¡ç¤ºä¾‹
### ç¤ºä¾‹1ï¼šæ·»åŠ ä¸€ä¸ªæ–°çš„ API ç«¯ç‚¹
**ç”¨æˆ·é—®é¢˜**: "æˆ‘éœ€è¦å®ç°ä¸€ä¸ªæ‹–æ‹½å’Œæ”¾ç½®åŠŸèƒ½çš„ç»„ä»¶ï¼Œä¹‹åå¯ä»¥æ·»åŠ åˆ°ä»»ä½•éœ€è¦æ‹–æ‹½çš„ç‰©ä½“ä¸Šã€‚"
**æœŸæœ›å›ç­”**: "ä¸ºäº†å®ç°æ‹–æ‹½å’Œæ”¾ç½®åŠŸèƒ½ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨`components/`ä¸‹åˆ›å»º `components/drag_and_drop.gd` æ–‡ä»¶ï¼Œç”¨äºå®ç°é€šç”¨ 2D æ‹–æ”¾åŠŸèƒ½ã€‚å®ƒçš„è®¾è®¡ç›®æ ‡æ˜¯â€œç»„åˆä¼˜äºç»§æ‰¿â€ï¼Œå¯ä»¥æŒ‚è½½åˆ°ä»»ä½• Area2D èŠ‚ç‚¹ä¸Šèµ‹äºˆå…¶æ‹–æ‹½èƒ½åŠ›ï¼ŒåŒæ—¶å¤„ç†äº† Zè½´æ’åºï¼ˆé˜²æ­¢é®æŒ¡ï¼‰ã€æ‹–æ‹½åç§»ï¼ˆæ‰‹æ„Ÿæ›´è‡ªç„¶ï¼‰ä»¥åŠ å…¨å±€è¾“å…¥æ•è·ï¼ˆé˜²æ­¢é¼ æ ‡ç”©é£ä¸¢å¤±çŠ¶æ€ï¼‰ç­‰ç»†èŠ‚é—®é¢˜ã€‚å…·ä½“ä»£ç å’Œé€»è¾‘åˆ†æå¦‚ä¸‹ï¼š

```gdscript
class_name DragAndDrop
extends Node

signal drag_canceled(starting_position: Vector2)
signal drag_started
signal dropped(starting_position: Vector2)

@export var enabled: bool = true
@export var target: Area2D

var starting_position: Vector2
var offset := Vector2.ZERO
var dragging: bool = false


func _ready() -> void:
	assert(target, "No target set for DragAndDrop")
	# unbind(1) ä¼šå¿½ç•¥æ‰è¿™ä¸ªä¿¡å·è¿æ¥çš„æœ€åä¸€ä¸ªå‚æ•°shape_idx
	target.input_event.connect(_on_target_input_event.unbind(1))


func _process(_delta: float) -> void:
	if dragging and target:
		target.global_position = target.get_global_mouse_position() + offset


func _input(event: InputEvent) -> void:
	# å–æ¶ˆæ‹–æ‹½ å’Œ æ”¾ä¸‹ï¼Œéœ€è¦æ”¾åˆ°inputä¸­ï¼Œé¼ æ ‡ç§»åŠ¨è¿‡å¿«æ—¶ï¼Œæœ‰å¯èƒ½é¼ æ ‡æ²¡æœ‰ç‚¹å‡»åˆ°targetä¸Š
	if dragging and event.is_action_pressed("cancel_drag"):
		_cancel_dragging()
	elif dragging and event.is_action_released("select"):
		_drop()


func _start_dragging() -> void:
	dragging = true
	starting_position = target.global_position
	target.add_to_group("dragging")
	target.z_index = 99
	offset = target.global_position - target.get_global_mouse_position()
	drag_started.emit()


func _end_dragging() -> void:
	dragging = false
	target.remove_from_group("dragging")
	target.z_index = 0


func _cancel_dragging() -> void:
	_end_dragging()
	drag_canceled.emit(starting_position)


func _drop() -> void:
	_end_dragging()
	dropped.emit(starting_position)


func _on_target_input_event(_viewport: Node, event: InputEvent) -> void:
	if not enabled:
		return

	var dragging_object = get_tree().get_first_node_in_group("dragging")
	if not dragging and dragging_object:
		return

	if not dragging and event.is_action_pressed("select"):
		_start_dragging()
```

æ ¸å¿ƒé€»è¾‘è§£æ

  1. ä¿¡å· (Signals)
   * drag_started: æ‹–æ‹½å¼€å§‹æ—¶å‘å‡ºã€‚
   * drag_canceled(starting_position): æ‹–æ‹½ä¸­é€”è¢«å–æ¶ˆï¼ˆå¦‚æŒ‰ä¸‹å³é”®ï¼‰æ—¶å‘å‡ºï¼Œå¹¶ä¼ å›æ‹–æ‹½å‰çš„åŸå§‹ä½ç½®ä»¥ä¾¿å¤ä½ã€‚
   * dropped(starting_position): æ‹–æ‹½æ­£å¸¸ç»“æŸï¼ˆæ¾å¼€å·¦é”®ï¼‰æ—¶å‘å‡ºï¼Œä¼ å›èµ·å§‹ä½ç½®ã€‚æ¥æ”¶è€…é€šå¸¸ä¼šåˆ¤æ–­æ”¾ä¸‹ä½ç½®æ˜¯å¦æœ‰æ•ˆï¼Œå¦‚æœæ— æ•ˆåˆ™åˆ©ç”¨è¿™ä¸ª starting_position
     è¿›è¡Œå¤ä½ã€‚

  2. çŠ¶æ€å˜é‡
   * target: è¢«æ‹–æ‹½çš„ Area2D èŠ‚ç‚¹ï¼ˆé€šå¸¸æ˜¯æ£‹å­ï¼‰ã€‚
   * dragging: å½“å‰æ˜¯å¦æ­£åœ¨è¢«æ‹–æ‹½ã€‚
   * starting_position: è®°å½•æ‹–æ‹½å¼€å§‹å‰çš„åæ ‡ï¼Œç”¨äºâ€œæ‚”æ£‹â€æˆ–æ— æ•ˆæ”¾ç½®åçš„å½’ä½ã€‚
   * offset: é¼ æ ‡ç‚¹å‡»ä½ç½®ä¸ç‰©ä½“ä¸­å¿ƒçš„åç§»é‡ï¼Œç¡®ä¿æ‹–æ‹½æ—¶ç‰©ä½“ä¸ä¼šç¬é—´è·³å˜åˆ°é¼ æ ‡ä¸­å¿ƒï¼Œä¿æŒæŠ“å–ç‚¹çš„ç›¸å¯¹ä½ç½®ã€‚

  3. è¾“å…¥å¤„ç†æµç¨‹

   * å¼€å§‹æ‹–æ‹½ (`_on_target_input_event`):
       * é€šè¿‡ target.input_event ç›‘å¬é¼ æ ‡åœ¨ç‰©ä½“ä¸Šçš„ç‚¹å‡»ã€‚
       * å½“æŒ‰ä¸‹ "select" (é€šå¸¸æ˜¯å·¦é”®) æ—¶è§¦å‘ã€‚
       * æ£€æŸ¥ dragging ç»„ï¼Œç¡®ä¿åŒä¸€æ—¶é—´åªèƒ½æ‹–æ‹½ä¸€ä¸ªç‰©ä½“ã€‚
       * è°ƒç”¨ _start_dragging():
           * è®°å½• starting_positionã€‚
           * è®¡ç®—å¹¶ä¿å­˜ offsetã€‚
           * å°†ç‰©ä½“åŠ å…¥ dragging ç»„ã€‚
           * æé«˜ z_index åˆ° 99ï¼Œç¡®ä¿æ‹–æ‹½ä¸­çš„ç‰©ä½“æ˜¾ç¤ºåœ¨æœ€ä¸Šå±‚ã€‚
           * å‘é€ drag_started ä¿¡å·ã€‚

   * æ‹–æ‹½ä¸­ (`_process`):
       * æ¯ä¸€å¸§æ›´æ–° target çš„ä½ç½®ï¼šé¼ æ ‡ä½ç½® + offsetã€‚
       * è¿™å®ç°äº†ç‰©ä½“ç´§è·Ÿé¼ æ ‡ç§»åŠ¨ã€‚

   * ç»“æŸ/å–æ¶ˆæ‹–æ‹½ (`_input`):
       * ä½¿ç”¨å…¨å±€ _input è€Œä¸æ˜¯å±€éƒ¨ _input_eventï¼Œé˜²æ­¢é¼ æ ‡ç§»åŠ¨å¤ªå¿«ç§»å‡ºç‰©ä½“èŒƒå›´åæ— æ³•æ¥æ”¶åˆ°æ¾å¼€æˆ–å–æ¶ˆäº‹ä»¶ã€‚
       * å–æ¶ˆ: æŒ‰ä¸‹ "cancel_drag" (é€šå¸¸æ˜¯å³é”®)ï¼Œè°ƒç”¨ `_cancel_dragging()`ï¼Œå¤ä½çŠ¶æ€å¹¶å‘é€ `drag_canceled`ã€‚
       * æ”¾ä¸‹: æ¾å¼€ "select" (å·¦é”®)ï¼Œè°ƒç”¨ _drop()ï¼Œå¤ä½çŠ¶æ€å¹¶å‘é€ droppedã€‚"